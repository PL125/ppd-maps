/*
Copyright 2013 Jared Wiltshire

This file is part of PPD Maps.

PPD Maps is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

PPD Maps is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with PPD Maps.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "exportcreator.h"
#include "mapsearch.h"
#include "conversion.h"

exportCreator::exportCreator(QString version, QList<map*>* mapList, QObject *parent) :
    QObject(parent), outFile(0), version(version), binSize(0), mapList(mapList)
{
}

void exportCreator::setFilename(QString filename)
{
    this->filename = filename;
}

void exportCreator::setBinSize(int binSize)
{
    this->binSize = binSize;
}

void exportCreator::exportXDF(bool exportFlat, bool exportZero, bool export1D, bool exportDTCs)
{
    outFile = new QFile(filename, this);
    outFile->open(QIODevice::WriteOnly);
    out.setDevice(outFile);

    // header data
    out << "<XDFFORMAT version=\"1.50\">" << endl;
    out << "  <XDFHEADER>" << endl;
    out << "    <flags>0x1</flags>" << endl;
    out << "    <description>Auto-generated by PPD-Maps " + version + "</description>" << endl;
    out << "    <author>Jared Wiltshire</author>" << endl;
    out << "    <baseoffset>0</baseoffset>" << endl;
    out << "    <DEFAULTS datasizeinbits=\"16\" sigdigits=\"2\" outputtype=\"1\" signed=\"0\" lsbfirst=\"0\" float=\"0\" />" << endl;
    out << "    <REGION type=\"0xFFFFFFFF\" startaddress=\"0x0\" size=\"" + formatHex(binSize, false, true) + "\" ";
    out << "regionflags=\"0x0\" name=\"Binary File\" desc=\"BDM File\" />" << endl;
    out << "  </XDFHEADER>" << endl;

    int mapNum = 1;
    // create entry for each map
    for (int i = 0; i < mapList->size(); i++) {
        map* mapI = mapList->at(i);

        if (mapI->isFlat() && !exportFlat) {
            continue;
        }
        if (mapI->isZero() && !exportZero) {
            continue;
        }
        if (mapI->getNumAxes() < 2 && !export1D) {
            continue;
        }
        if (mapI->isDTC() && !exportDTCs) {
            continue;
        }

        out << "  <XDFTABLE uniqueid=\"0x" << QString::number(i+1,16).toUpper() << "\" flags=\"0x0\">" << endl;

        if (mapI->getLabel().isEmpty()) {
            out << "    <title>Map " << QString::number(mapNum++) << " " \
                << QString::number(mapI->getXDim()) << "x" << QString::number(mapI->getYDim()) \
                << "</title>" << endl;
        }
        else {
            out << "    <title>" << mapI->getLabel() << "</title>" << endl;
        }

        // x-axis
        axis* xAxis = mapI->getAxis(0);
        out << "    <XDFAXIS id=\"x\" uniqueid=\"0x0\">" << endl;
        out << "      <EMBEDDEDDATA";
        if (!xAxis->isFixed())
        out << " mmedaddress=\"0x" << QString::number(xAxis->getAddress(), 16).toUpper() << "\"";
        out << " mmedelementsizebits=\"" << QString::number(xAxis->getWordSize() * 8) << "\"";
        if (!xAxis->isFixed()) {
        out << " mmedcolcount=\"" << QString::number(xAxis->getLength()) << "\"" \
            << " mmedmajorstridebits=\"" <<  QString::number(xAxis->getWordSize() * 8) << "\"";
        }
        else
        out << " mmedmajorstridebits=\"0\"";
        out    << " />" << endl;
        if (!xAxis->getUnits().isEmpty()) {
        out << "      <units>" << xAxis->getUnits() << "</units>" << endl;
        }
        out << "      <indexcount>" << QString::number(xAxis->getLength()) << "</indexcount>" << endl;
        out << "      <decimalpl>" << xAxis->getDecimalPoints() << "</decimalpl>" << endl;
        if (!xAxis->isFixed())
        out << "      <embedinfo type=\"1\" />" << endl;
        out << "      <datatype>0</datatype>" << endl;
        out << "      <unittype>0</unittype>" << endl;
        out << "      <DALINK index=\"0\" />" << endl;
        if (xAxis->isFixed())
            for(int i = 0; i < xAxis->getLength(); i++) {
                out << "      <LABEL index=\"" << i << "\" value=\"" << i << "\" />" << endl;
            }
        out << "      <MATH equation=\"" << xAxis->getEquation() << "\">" << endl;
        out << "        <VAR id=\"X\" />" << endl;
        out << "      </MATH>" << endl;
        out << "    </XDFAXIS>" << endl;

        // y-axis
        if (mapI->getNumAxes() > 1) {
            axis* yAxis = mapI->getAxis(1);
            out << "    <XDFAXIS id=\"y\" uniqueid=\"0x0\">" << endl;
            out << "      <EMBEDDEDDATA mmedaddress=\"0x" << QString::number(yAxis->getAddress(), 16).toUpper() \
                << "\" mmedelementsizebits=\"" << QString::number(yAxis->getWordSize() * 8) \
                << "\" mmedcolcount=\"" << QString::number(yAxis->getLength()) \
                << "\" mmedmajorstridebits=\"" << QString::number(yAxis->getWordSize() * 8) \
                << "\" />" << endl;
            if (!yAxis->getUnits().isEmpty()) {
                out << "      <units>" << yAxis->getUnits() << "</units>" << endl;
            }
            out << "      <indexcount>" << QString::number(yAxis->getLength()) << "</indexcount>" << endl;
            out << "      <decimalpl>" << yAxis->getDecimalPoints() << "</decimalpl>" << endl;
            out << "      <embedinfo type=\"1\" />" << endl;
            out << "      <datatype>0</datatype>" << endl;
            out << "      <unittype>0</unittype>" << endl;
            out << "      <DALINK index=\"0\" />" << endl;
            out << "      <MATH equation=\"" << yAxis->getEquation() << "\">" << endl;
            out << "        <VAR id=\"X\" />" << endl;
            out << "      </MATH>" << endl;
            out << "    </XDFAXIS>" << endl;
        }
        else {
            out << "    <XDFAXIS id=\"y\" uniqueid=\"0x0\">" << endl;
            out << "      <EMBEDDEDDATA mmedelementsizebits=\"8\" mmedmajorstridebits=\"0\" />" << endl;
            out << "      <indexcount>1</indexcount>" << endl;
            out << "      <datatype>0</datatype>" << endl;
            out << "      <unittype>0</unittype>" << endl;
            out << "      <DALINK index=\"0\" />" << endl;
            out << "      <LABEL index=\"0\" value=\"0.00\" />" << endl;
            out << "      <MATH equation=\"X\">" << endl;
            out << "        <VAR id=\"X\" />" << endl;
            out << "      </MATH>" << endl;
            out << "    </XDFAXIS>" << endl;
        }

        // z-axis
        out << "    <XDFAXIS id=\"z\">" << endl;
        out << "      <EMBEDDEDDATA mmedaddress=\"0x" << QString::number(mapI->getAddress(), 16).toUpper() \
            << "\" mmedelementsizebits=\"" << QString::number(mapI->getWordSize() * 8) \
            << "\" mmedrowcount=\"" << QString::number(mapI->getYDim()) \
            << "\" mmedcolcount=\"" << QString::number(mapI->getXDim()) \
            << "\" />" << endl;
        if (!mapI->getUnits().isEmpty()) {
            out << "      <units>" << mapI->getUnits() << "</units>" << endl;
        }
        out << "      <decimalpl>" << mapI->getDecimalPoints() << "</decimalpl>" << endl;
        out << "      <min>0.000000</min>" << endl;
        out << "      <max>255.000000</max>" << endl;
        out << "      <outputtype>1</outputtype>" << endl;
        out << "      <MATH equation=\"" << mapI->getEquation() << "\">" << endl;
        out << "        <VAR id=\"X\" />" << endl;
        out << "      </MATH>" << endl;
        out << "    </XDFAXIS>" << endl;

        out << "  </XDFTABLE>" << endl;
    }

    out << "</XDFFORMAT>" << endl;

    out.flush();
    out.setDevice(0);
    outFile->close();

    emit log("XDF file exported: " + filename, standardLvl, true);
}

void exportCreator::exportA2L(bool exportFlat, bool exportZero, bool export1D, bool exportDTCs)
{
    outFile = new QFile(filename, this);
    outFile->open(QIODevice::WriteOnly);
    out.setDevice(outFile);

    printA2LHeader();

    QList<conversion> convList;
    QList<axis*> axisList;

    int mapNum = 1;
    int dtcNum = 1;

    // create entry for each map
    for (int i = 0; i < mapList->size(); i++) {
        map* cMap = mapList->at(i);

        if (cMap->isFlat() && !exportFlat) {
            continue;
        }
        if (cMap->isZero() && !exportZero) {
            continue;
        }
        if (cMap->getNumAxes() < 2 && !export1D) {
            continue;
        }
        if (cMap->isDTC() && !exportDTCs) {
            continue;
        }

        // values to be used in writing out map
        QString mapLabel = cMap->getLabel();
        if (mapLabel == "") {
            mapLabel = "Map " + QString::number(mapNum);
        }
        QString addr = "0x" + QString::number(cMap->getAddress(), 16);

        conversion mapConv(cMap, convList.length());
        if (!convList.contains(mapConv)) {
            convList.append(mapConv);
        }

        // begin writing map/curve/value
        if (!cMap->isDTC())
            out << "    /begin CHARACTERISTIC map" << formatIndex(mapNum) << endl;
        else
            out << "    /begin CHARACTERISTIC dtc" << formatIndex(dtcNum) << endl;
        out << "      \"" + mapLabel + "\"" << endl;
        if (cMap->getXDim() == 1 && cMap->getAxis(0)->isFixed())
            out << "      VALUE" << endl;
        else if (cMap->getAxis(1) == 0)
            out << "      CURVE" << endl;
        else
            out << "      MAP" << endl;
        out << "      " << addr << endl;
        out << "      REC_" << (cMap->getSigned() ? "S" : "U") << cMap->getWordSize() << endl;
        out << "      " << formatFloat(cMap->calcRange()) << endl;
        out << "      " << convList.at(convList.indexOf(mapConv)).conversionID() << endl;
        out << "      " << formatFloat(cMap->calcMin()) << endl;
        out << "      " << formatFloat(cMap->calcMax()) << endl;
        if (!cMap->isDTC())
            out << "      DISPLAY_IDENTIFIER MAP" << formatIndex(mapNum++).toUpper() << endl;
        else
            out << "      DISPLAY_IDENTIFIER DTC" << formatIndex(dtcNum++).toUpper() << endl;
        out << "      FORMAT \"%6." << cMap->getDecimalPoints() << "\"" << endl;

        // write axes (unless its a single value)
        if (!(cMap->getXDim() == 1 && cMap->getAxis(0)->isFixed())) {
            for (int j = 0; j < cMap->getNumAxes(); j++) {
                axis* jAxis = cMap->getAxis(j);
                if (!axisList.contains(jAxis) && !jAxis->isFixed()) {
                    axisList.append(jAxis);
                }

                conversion axConv(jAxis, convList.length());
                if (!convList.contains(axConv)) {
                    convList.append(axConv);
                }

                // begin writing axis reference
                out << "      /begin AXIS_DESCR" << endl;
                if (!jAxis->isFixed())
                    out << "         COM_AXIS" << endl;
                else
                    out << "         FIX_AXIS" << endl;
                out << "         dummy" << endl;
                out << "         " << convList.at(convList.indexOf(axConv)).conversionID() << endl;
                out << "         " << jAxis->getLength() << endl;
                out << "         " << formatFloat(jAxis->calcMin()) << endl;
                out << "         " << formatFloat(jAxis->calcMax()) << endl;
                out << "         FORMAT \"%6." << jAxis->getDecimalPoints() << "\"" << endl;
                if (!jAxis->isFixed())
                    out << "         AXIS_PTS_REF axis" << formatIndex(axisList.indexOf(jAxis)+1) << endl;
                else
                    out << "         FIX_AXIS_PAR_DIST 0 1 " << jAxis->getLength() << endl;
                out << "      /end AXIS_DESCR" << endl;
            }
        }

        out << "      /begin IF_DATA ETK" << endl;
        out << "        DP_BLOB " << addr << " " << cMap->getNumBytes() << endl;
        out << "      /end IF_DATA" << endl;
        out << "    /end CHARACTERISTIC" << endl << endl;
    }

    // write out axis descriptions
    for (int i = 0; i < axisList.length(); i++) {
        axis* iAxis = axisList.at(i);
        conversion axConv(iAxis, convList.length());
        if (!convList.contains(axConv)) {
            convList.append(axConv);
        }

        out << "    /begin AXIS_PTS axis" << formatIndex(axisList.indexOf(iAxis)+1) << endl;
        out << "      \"" << iAxis->getLabel() << "\"" << endl;
        out << "      0x" << QString::number(iAxis->getAddress(), 16) << endl;
        out << "      dummy" << endl;
        out << "      REC_AXS_" << (iAxis->getSigned() ? "S" : "U") << iAxis->getWordSize() << endl;
        out << "      " << formatFloat(iAxis->calcRange()) << endl;
        out << "      " << convList.at(convList.indexOf(axConv)).conversionID() << endl;
        out << "      " << iAxis->getLength() << endl;
        out << "      " << formatFloat(iAxis->calcMin()) << endl;
        out << "      " << formatFloat(iAxis->calcMax()) << endl;
        out << "      FORMAT \"%6." << iAxis->getDecimalPoints() << "\"" << endl;
        out << "      /begin IF_DATA ETK" << endl;
        out << "         DP_BLOB 0x" << QString::number(iAxis->getAddress(), 16) << " " << iAxis->getNumBytes() << endl;
        out << "      /end IF_DATA" << endl;
        out << "    /end AXIS_PTS" << endl << endl;
    }

    // write out conversion functions (i.e. scale & offsets)
    for (int i = 0; i < convList.length(); i++) {
        out << "    /begin COMPU_METHOD " << convList.at(i).conversionID() << endl;
        out << "      \"\"" << endl;
        out << "      RAT_FUNC" << endl;
        out << "      \"%6.3\"" << endl;
        out << "      \"" << convList.at(i).units << "\"" << endl;
        out << "      COEFFS 0 " << formatFloat(1.0 / convList.at(i).scaleFactor);
        out << " " << formatFloat(-convList.at(i).offset / convList.at(i).scaleFactor) << " 0 0 1" << endl;
        out << "    /end COMPU_METHOD" << endl << endl;
    }

    // write out map groups and axes
    out << "    /begin FUNCTION PPDMaps" << endl;
    out << "      \"PPD Maps\"" << endl;
    out << "      /begin SUB_FUNCTION" << endl;
    out << "        LabeledMaps" << endl;
    out << "        UnlabeledMaps" << endl;
    out << "        DTCs" << endl;
    out << "        Switches" << endl;
    out << "      /end SUB_FUNCTION" << endl;
    out << "      /begin DEF_CHARACTERISTIC" << endl;
    for (int i = 0; i < axisList.length(); i++) {
        out << "        axis" << formatIndex(i+1) << endl;
    }
    out << "      /end DEF_CHARACTERISTIC" << endl;
    out << "    /end FUNCTION" << endl << endl;

    // write labeled maps
    out << "    /begin FUNCTION LabeledMaps" << endl;
    out << "      \"Labeled maps\"" << endl;
    out << "      /begin DEF_CHARACTERISTIC" << endl;
    mapNum = 1;
    for (int i = 0; i < mapList->length(); i++) {
        map* mapAtI = mapList->at(i);
        if (!mapAtI->isDTC()) {
            QString lbl = mapAtI->getLabel();
            if (lbl != "" && !(lbl.left(2) == "Sw" && mapAtI->dimensionsStr() == "1x1")) {
                out << "        map" << formatIndex(mapNum) << endl;
            }
            mapNum++;
        }
    }
    out << "      /end DEF_CHARACTERISTIC" << endl;
    out << "    /end FUNCTION" << endl << endl;

    // write switches
    out << "    /begin FUNCTION Switches" << endl;
    out << "      \"Switches\"" << endl;
    out << "      /begin DEF_CHARACTERISTIC" << endl;
    mapNum = 1;
    for (int i = 0; i < mapList->length(); i++) {
        map* mapAtI = mapList->at(i);
        if (!mapAtI->isDTC()) {
            QString lbl = mapAtI->getLabel();
            if (lbl.left(2) == "Sw" && mapAtI->dimensionsStr() == "1x1") {
                out << "        map" << formatIndex(mapNum) << endl;
            }
            mapNum++;
        }
    }
    out << "      /end DEF_CHARACTERISTIC" << endl;
    out << "    /end FUNCTION" << endl << endl;

    // write unlabeled maps
    out << "    /begin FUNCTION UnlabeledMaps" << endl;
    out << "      \"Unlabeled maps\"" << endl;
    out << "      /begin DEF_CHARACTERISTIC" << endl;
    mapNum = 1;
    for (int i = 0; i < mapList->length(); i++) {
        if (!mapList->at(i)->isDTC()) {
            if (mapList->at(i)->getLabel() == "") {
                out << "        map" << formatIndex(mapNum) << endl;
            }
            mapNum++;
        }
    }
    out << "      /end DEF_CHARACTERISTIC" << endl;
    out << "    /end FUNCTION" << endl << endl;

    // write out list of DTCs
    if (exportDTCs) {
        out << "    /begin FUNCTION DTCs" << endl;
        out << "      \"Diagnostic Trouble Codes\"" << endl;
        out << "      /begin DEF_CHARACTERISTIC" << endl;
        dtcNum = 1;
        for (int i = 0; i < mapList->length(); i++) {
            if (mapList->at(i)->isDTC()) {
                out << "        dtc" << formatIndex(dtcNum++) << endl;
            }
        }
        out << "      /end DEF_CHARACTERISTIC" << endl;
        out << "    /end FUNCTION" << endl << endl;
    }

    printA2LFooter();

    out.flush();
    out.setDevice(0);
    outFile->close();

    emit log("A2L file exported: " + filename, standardLvl, true);
}

void exportCreator::printA2LHeader()
{
    out << "/*" << endl;
    out << "Generated by PPD-Maps " + version << endl;
    out << "By Jared Wiltshire" << endl;
    out << "http://ppdmaps.jazdw.net/" << endl;
    out << "*/" << endl;
    out << "ASAP2_VERSION 1 41" << endl;
    out << "/begin PROJECT" << endl;
    out << "  PPD" << endl;
    out << "  \"Auto-generated by PPD-Maps " + version + "\"" << endl;
    out << "  /begin MODULE PPD \"\"" << endl;
    out << "    /begin MOD_PAR \"\"" << endl;
    out << "      /begin MEMORY_SEGMENT _ROM" << endl;
    out << "      \"\"" << endl;
    out << "      DATA" << endl;
    out << "      FLASH" << endl;
    out << "      EXTERN" << endl;
    out << "      0x40000" << endl;
    out << "      0x3d000" << endl;
    out << "      -1 -1 -1 -1 -1" << endl;
    out << "      /begin IF_DATA ETK" << endl;
    out << "        DP_BLOB 0x40000 0x3d000 " << endl;
    out << "      /end IF_DATA" << endl;
    out << "      /end MEMORY_SEGMENT" << endl;
    out << "    /end MOD_PAR" << endl << endl;

    out << "    /begin MOD_COMMON \"\"" << endl;
    out << "      DEPOSIT ABSOLUTE" << endl;
    out << "      BYTE_ORDER MSB_FIRST" << endl;
    out << "      ALIGNMENT_BYTE 1" << endl;
    out << "      ALIGNMENT_WORD 2" << endl;
    out << "      ALIGNMENT_LONG 4" << endl;
    out << "      ALIGNMENT_FLOAT32_IEEE 4" << endl;
    out << "      ALIGNMENT_FLOAT64_IEEE 8" << endl;
    out << "    /end MOD_COMMON" << endl << endl;

    out << "    /begin MEASUREMENT dummy" << endl;
    out << "      \"\"" << endl;
    out << "      UBYTE" << endl;
    out << "      CNV_0" << endl;
    out << "      1" << endl;
    out << "      0." << endl;
    out << "      0." << endl;
    out << "      255." << endl;
    out << "      DISPLAY_IDENTIFIER DUMMY" << endl;
    out << "      ECU_ADDRESS 0xffffff" << endl;
    out << "      FORMAT \"%0.0\"" << endl;
    out << "      /begin IF_DATA ETK" << endl;
    out << "        KP_BLOB 0xffffff 0 1 " << endl;
    out << "      /end IF_DATA" << endl;
    out << "    /end MEASUREMENT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_U1" << endl;
    out << "      FNC_VALUES 1 UBYTE COLUMN_DIR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_U2" << endl;
    out << "      FNC_VALUES 1 UWORD COLUMN_DIR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_U4" << endl;
    out << "      FNC_VALUES 1 ULONG COLUMN_DIR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_S1" << endl;
    out << "      FNC_VALUES 1 SBYTE COLUMN_DIR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_S2" << endl;
    out << "      FNC_VALUES 1 SWORD COLUMN_DIR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_S4" << endl;
    out << "      FNC_VALUES 1 SLONG COLUMN_DIR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_AXS_U1" << endl;
    out << "      NO_AXIS_PTS_X 1 UBYTE" << endl;
    out << "      AXIS_PTS_X 2 UBYTE INDEX_INCR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;

    out << "    /begin RECORD_LAYOUT REC_AXS_U2" << endl;
    out << "      NO_AXIS_PTS_X 1 UWORD" << endl;
    out << "      AXIS_PTS_X 2 UWORD INDEX_INCR DIRECT" << endl;
    out << "    /end RECORD_LAYOUT" << endl << endl;
}

void exportCreator::printA2LFooter()
{
    out << "  /end MODULE" << endl;
    out << "/end PROJECT" << endl;
}

QString exportCreator::formatIndex(int i)
{
    return QString("%1").arg(i, 4, 10, QChar('0'));
}

QString exportCreator::formatFloat(double num)
{
    return QString::number(num);
    /*
    QString result = QString::number(num);
    if (result.contains('.'))
        return result;
    return result + '.';
    */
}
